#!/bin/bash

# Git Repository Monitor - Um monitor estilo htop para reposit√≥rios Git
# Autor: Gabriel Augusto Gon√ßalves <gabri.augustog@gmail.com>
# Vers√£o: 1.0.1
# Uso: ./git-monitor.sh [caminho_do_repositorio] [intervalo_segundos]

# Vers√£o
VERSION="1.0.1"

# Cores ANSI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configura√ß√µes padr√£o
REPO_PATH="${1:-.}"

# Verificar argumentos especiais
if [ "$1" == "--version" ] || [ "$1" == "-v" ]; then
    echo "git-monitor version $VERSION"
    echo "Copyright (c) 2024 Gabriel Augusto Gon√ßalves"
    echo "License: MIT"
    exit 0
fi

if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
    echo "Git Monitor v$VERSION - Real-time Git repository monitor"
    echo ""
    echo "Usage: git-monitor [REPOSITORY] [INTERVAL]"
    echo ""
    echo "Arguments:"
    echo "  REPOSITORY  Path to git repository (default: current directory)"
    echo "  INTERVAL    Refresh interval in seconds (default: 2)"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -v, --version  Show version information"
    echo ""
    echo "Keyboard shortcuts:"
    echo "  q    Quit"
    echo "  r    Refresh immediately"
    echo "  d    Toggle diff preview"
    echo "  +    Increase refresh interval"
    echo "  -    Decrease refresh interval"
    echo ""
    echo "Author: Gabriel Augusto Gon√ßalves <gabri.augustog@gmail.com>"
    echo "Repository: https://github.com/gaugustog/git-monitor"
    exit 0
fi

# Converter para caminho absoluto logo no in√≠cio
REPO_PATH=$(realpath "$REPO_PATH" 2>/dev/null || echo "$REPO_PATH")
REFRESH_INTERVAL="${2:-2}"
SHOW_DIFF_PREVIEW=true
MAX_DIFF_LINES=5

# Validar se √© um reposit√≥rio Git
if ! git -C "$REPO_PATH" rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Erro: '$REPO_PATH' n√£o √© um reposit√≥rio Git v√°lido.${NC}"
    exit 1
fi

# Buffer para conte√∫do
SCREEN_BUFFER=""

# Fun√ß√£o para adicionar ao buffer
buffer_add() {
    SCREEN_BUFFER="${SCREEN_BUFFER}$1"
}

# Fun√ß√£o para limpar buffer
buffer_clear() {
    SCREEN_BUFFER=""
}

# Fun√ß√£o para renderizar buffer
buffer_render() {
    # Usar c√≥digo ANSI para mover cursor para o topo sem limpar
    printf '\033[H'
    # Limpar da posi√ß√£o atual at√© o fim da tela
    printf '\033[J'
    # Imprimir o buffer
    printf "%b" "$SCREEN_BUFFER"
}

# Fun√ß√£o para obter o tamanho do terminal
get_terminal_size() {
    TERM_COLS=$(tput cols)
    TERM_LINES=$(tput lines)
}

# Fun√ß√£o para desenhar uma linha horizontal
draw_line() {
    local line=$(printf '%*s' "${TERM_COLS}" '' | tr ' ' '-')
    buffer_add "${line}\n"
}

# Fun√ß√£o para centralizar texto
center_text() {
    local text="$1"
    local width="${2:-$TERM_COLS}"
    local text_length=${#text}
    local padding=$(( (width - text_length) / 2 ))
    printf "%*s%s%*s" $padding "" "$text" $padding ""
}

# Fun√ß√£o para formatar tamanho de arquivo
format_size() {
    local size=$1
    if [ $size -lt 1024 ]; then
        echo "${size}B"
    elif [ $size -lt 1048576 ]; then
        echo "$((size / 1024))KB"
    else
        echo "$((size / 1048576))MB"
    fi
}

# Fun√ß√£o para obter informa√ß√µes do reposit√≥rio
get_repo_info() {
    # Salvar diret√≥rio atual
    local original_dir=$(pwd)
    
    # Mudar para o reposit√≥rio
    cd "$REPO_PATH" || return 1
    
    # Informa√ß√µes b√°sicas
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "HEAD detached")
    LAST_COMMIT=$(git log -1 --pretty=format:"%h - %s" 2>/dev/null || echo "No commits")
    LAST_COMMIT_TIME=$(git log -1 --pretty=format:"%ar" 2>/dev/null || echo "")
    REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "No remote")
    
    # Status dos arquivos
    MODIFIED_FILES=$(git status --porcelain | grep -c "^ M")
    STAGED_FILES=$(git status --porcelain | grep -c "^M\|^A")
    UNTRACKED_FILES=$(git status --porcelain | grep -c "^??")
    DELETED_FILES=$(git status --porcelain | grep -c "^ D")
    
    # Commits ahead/behind
    if git remote show origin &>/dev/null; then
        COMMITS_AHEAD=$(git rev-list --count HEAD...origin/"$CURRENT_BRANCH" 2>/dev/null || echo "0")
        COMMITS_BEHIND=$(git rev-list --count origin/"$CURRENT_BRANCH"...HEAD 2>/dev/null || echo "0")
    else
        COMMITS_AHEAD="N/A"
        COMMITS_BEHIND="N/A"
    fi
    
    # Stash count
    STASH_COUNT=$(git stash list | wc -l)
    
    # Voltar para o diret√≥rio original
    cd "$original_dir" || return 1
}

# Fun√ß√£o para exibir o header
display_header() {
    buffer_add "${BOLD}${CYAN}== GIT REPOSITORY MONITOR ==${NC}\n"
    draw_line
    buffer_add "${WHITE}Repository:${NC} ${BLUE}$(basename "$REPO_PATH")${NC} | ${WHITE}Path:${NC} ${GRAY}$(realpath "$REPO_PATH")${NC}\n"
    buffer_add "${WHITE}Time:${NC} $(date '+%Y-%m-%d %H:%M:%S') | ${WHITE}Refresh:${NC} ${REFRESH_INTERVAL}s | ${WHITE}Press${NC} ${YELLOW}q${NC} ${WHITE}to quit${NC}\n"
    draw_line
}

# Fun√ß√£o para exibir status do branch
display_branch_info() {
    buffer_add "${BOLD}${GREEN}üåø Branch Information${NC}\n"
    buffer_add "  ${WHITE}Current Branch:${NC} ${YELLOW}$CURRENT_BRANCH${NC}\n"
    buffer_add "  ${WHITE}Remote:${NC} ${GRAY}$REMOTE_URL${NC}\n"
    buffer_add "  ${WHITE}Last Commit:${NC} $LAST_COMMIT ${GRAY}($LAST_COMMIT_TIME)${NC}\n"
    
    if [ "$COMMITS_AHEAD" != "N/A" ]; then
        buffer_add "  ${WHITE}Sync Status:${NC} ${GREEN}‚Üë$COMMITS_AHEAD${NC} ahead, ${RED}‚Üì$COMMITS_BEHIND${NC} behind\n"
    fi
    
    if [ "$STASH_COUNT" -gt 0 ]; then
        buffer_add "  ${WHITE}Stashes:${NC} ${MAGENTA}$STASH_COUNT${NC}\n"
    fi
    buffer_add "\n"
}

# Fun√ß√£o para exibir estat√≠sticas de arquivos
display_file_stats() {
    buffer_add "${BOLD}${YELLOW}üìÅ File Statistics${NC}\n"
    
    # Criar barra de progresso visual
    local total_changes=$((MODIFIED_FILES + STAGED_FILES + UNTRACKED_FILES + DELETED_FILES))
    
    buffer_add "  ${GREEN}‚óè${NC} Staged:    $(printf "%3d" $STAGED_FILES) files\n"
    buffer_add "  ${YELLOW}‚óè${NC} Modified:  $(printf "%3d" $MODIFIED_FILES) files\n"
    buffer_add "  ${CYAN}‚óè${NC} Untracked: $(printf "%3d" $UNTRACKED_FILES) files\n"
    buffer_add "  ${RED}‚óè${NC} Deleted:   $(printf "%3d" $DELETED_FILES) files\n"
    buffer_add "  ---------------${NC}\n"
    buffer_add "  ${WHITE}Total:${NC}      $(printf "%3d" $total_changes) changes\n"
    buffer_add "\n"
}

# Fun√ß√£o para exibir arquivos modificados
display_changed_files() {
    buffer_add "${BOLD}${MAGENTA}üìù Changed Files${NC}\n"
    
    local count=0
    local max_files=10
    local total_changes=$((MODIFIED_FILES + STAGED_FILES + UNTRACKED_FILES + DELETED_FILES))
    
    # Salvar diret√≥rio atual e mudar para o repo
    local original_dir=$(pwd)
    cd "$REPO_PATH" || return
    
    # Arquivos staged
    if [ "$STAGED_FILES" -gt 0 ]; then
        while IFS= read -r line; do
            [ $count -ge $max_files ] && break
            file=$(echo "$line" | cut -c4-)
            buffer_add "  ${GREEN}[S]${NC} $file\n"
            ((count++))
        done < <(git status --porcelain | grep "^M\|^A")
    fi
    
    # Arquivos modificados
    if [ "$MODIFIED_FILES" -gt 0 ]; then
        while IFS= read -r line; do
            [ $count -ge $max_files ] && break
            file=$(echo "$line" | cut -c4-)
            if [ -f "$file" ]; then
                size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
                buffer_add "  ${YELLOW}[M]${NC} $file ${GRAY}($(format_size $size))${NC}\n"
            else
                buffer_add "  ${YELLOW}[M]${NC} $file\n"
            fi
            ((count++))
        done < <(git status --porcelain | grep "^ M")
    fi
    
    # Arquivos n√£o rastreados - INCLUINDO BIN√ÅRIOS
    if [ "$UNTRACKED_FILES" -gt 0 ]; then
        while IFS= read -r line; do
            [ $count -ge $max_files ] && break
            file=$(echo "$line" | cut -c4-)
            
            # Detectar tipo de arquivo
            local file_type=""
            if [[ $file =~ \.(jpg|jpeg|png|gif|svg|webp|ico|bmp)$ ]]; then
                file_type=" üñºÔ∏è"
            elif [[ $file =~ \.(mp4|avi|mov|webm|mkv)$ ]]; then
                file_type=" üé•"
            elif [[ $file =~ \.(pdf|doc|docx|xls|xlsx)$ ]]; then
                file_type=" üìÑ"
            elif [[ $file =~ \.(zip|tar|gz|7z|rar)$ ]]; then
                file_type=" üì¶"
            fi
            
            buffer_add "  ${CYAN}[U]${NC} $file$file_type\n"
            ((count++))
        done < <(git status --porcelain | grep "^??")
    fi
    
    # Arquivos deletados
    if [ "$DELETED_FILES" -gt 0 ]; then
        while IFS= read -r line; do
            [ $count -ge $max_files ] && break
            file=$(echo "$line" | cut -c4-)
            buffer_add "  ${RED}[D]${NC} $file\n"
            ((count++))
        done < <(git status --porcelain | grep "^ D")
    fi
    
    # Voltar para o diret√≥rio original
    cd "$original_dir" || return
    
    if [ $count -eq 0 ]; then
        buffer_add "  ${GRAY}Working tree clean${NC}\n"
    elif [ $total_changes -gt $max_files ]; then
        buffer_add "  ${GRAY}... and $((total_changes - max_files)) more files${NC}\n"
    fi
    buffer_add "\n"
}

# Fun√ß√£o para exibir preview de diff
display_diff_preview() {
    if [ "$SHOW_DIFF_PREVIEW" = true ] && [ "$MODIFIED_FILES" -gt 0 ]; then
        buffer_add "${BOLD}${CYAN}üîç Recent Changes Preview${NC}\n"
        
        # Salvar diret√≥rio atual
        local original_dir=$(pwd)
        cd "$REPO_PATH" || return
        
        # Pegar o primeiro arquivo modificado
        local first_modified=$(git status --porcelain | grep "^ M" | head -1 | cut -c4-)
        
        if [ -n "$first_modified" ]; then
            buffer_add "  ${WHITE}File:${NC} $first_modified\n"
            buffer_add "  ---------------${NC}\n"
            
            local line_count=0
            while IFS= read -r line && [ $line_count -lt $MAX_DIFF_LINES ]; do
                if [[ $line == +* ]]; then
                    buffer_add "  ${GREEN}$line${NC}\n"
                elif [[ $line == -* ]]; then
                    buffer_add "  ${RED}$line${NC}\n"
                else
                    buffer_add "  ${GRAY}$line${NC}\n"
                fi
                ((line_count++))
            done < <(git diff "$first_modified" 2>/dev/null | tail -n +5)
        fi
        
        # Voltar para o diret√≥rio original
        cd "$original_dir" || return
        
        buffer_add "\n"
    fi
}

# Fun√ß√£o para exibir atividade recente
display_recent_activity() {
    buffer_add "${BOLD}${BLUE}‚è∞ Recent Activity${NC}\n"
    
    # Usar git -C para evitar cd
    while IFS= read -r line; do
        buffer_add "  ${GRAY}$line${NC}\n"
    done < <(git -C "$REPO_PATH" log --oneline --graph --decorate -5 2>/dev/null)
    
    buffer_add "\n"
}

# Fun√ß√£o principal de monitoramento
monitor_loop() {
    # Configurar m√∫ltiplos traps para diferentes sinais
    trap 'cleanup_and_exit' INT TERM
    trap 'cleanup_and_exit' EXIT
    trap 'cleanup_and_exit' HUP
    trap 'cleanup_and_exit' QUIT
    
    # Configurar terminal
    setup_terminal
    
    while true; do
        get_terminal_size
        buffer_clear
        get_repo_info
        
        display_header
        display_branch_info
        display_file_stats
        display_changed_files
        display_diff_preview
        display_recent_activity
        
        # Footer
        draw_line
        buffer_add "${GRAY}Last updated: $(date '+%H:%M:%S') | Next refresh in ${REFRESH_INTERVAL}s${NC}\n"
        buffer_add "${GRAY}Commands: [q]uit | [r]efresh | [d]iff toggle | [+/-] change interval${NC}\n"
        
        # Renderizar buffer
        buffer_render
        
        # Verificar input do usu√°rio (non-blocking)
        read -t "$REFRESH_INTERVAL" -n 1 key
        
        case $key in
            q|Q)
                cleanup_and_exit
                ;;
            r|R)
                continue
                ;;
            d|D)
                SHOW_DIFF_PREVIEW=$([ "$SHOW_DIFF_PREVIEW" = true ] && echo false || echo true)
                ;;
            +)
                REFRESH_INTERVAL=$((REFRESH_INTERVAL + 1))
                ;;
            -)
                [ $REFRESH_INTERVAL -gt 1 ] && REFRESH_INTERVAL=$((REFRESH_INTERVAL - 1))
                ;;
        esac
    done
}

# Configurar terminal
setup_terminal() {
    # Salvar configura√ß√µes do terminal
    SAVED_STTY=$(stty -g 2>/dev/null)
    
    # Desabilitar echo e buffering com fallback
    stty -echo -icanon min 0 time 0 2>/dev/null || true
    
    # Esconder cursor
    printf '\033[?25l'
    
    # Limpar tela inicial
    printf '\033[2J\033[H'
}

# Limpar e sair
cleanup_and_exit() {
    # Sempre tentar restaurar, mesmo se SAVED_STTY estiver vazio
    if [ -n "$SAVED_STTY" ]; then
        stty "$SAVED_STTY" 2>/dev/null || stty sane
    else
        stty sane
    fi
    
    # Mostrar cursor
    printf '\033[?25h'
    
    # Limpar tela
    printf '\033[2J\033[H'
    
    # Garantir que o echo est√° ligado
    stty echo 2>/dev/null || true
    
    echo -e "${YELLOW}Monitoring stopped.${NC}"
    exit 0
}

# Iniciar monitoramento
echo -e "${CYAN}Starting Git Repository Monitor...${NC}"
echo -e "${GRAY}Repository: $REPO_PATH${NC}"
echo -e "${GRAY}Refresh interval: ${REFRESH_INTERVAL}s${NC}"
sleep 1

# Garantir limpeza ao sair de qualquer forma
trap 'cleanup_and_exit' EXIT

monitor_loop
